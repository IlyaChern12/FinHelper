
<div style="text-align: center"> <h1>РАЗРАБОТКА ВЕБ-ПРИЛОЖЕНИЯ: ПРИЛОЖЕНИЕ FINHELPER</h1></div>

<br/><br/>

<div style="text-align: center"> <h2>ЧЕРНЯХОВСКИЙ И.С., ГАЛИМЗЯНОВ И.Ф., ЧЕПЛЯ В.П., УМРАЛИЕВА Н.Р.</h2></div>

<br/><br/>
<br/><br/>
<br/><br/>

<div style="text-align: center"> <h2>CОДЕРЖАНИЕ</h2></div>

1. [ТЕОРЕТИЧЕСКАЯ БАЗА](#teo)
2. [ЦЕЛИ И ЗАДАЧИ](#scores)
3. [ТЕХНИЧЕСКИЕ ТРЕБОВАНИЯ](#tech)
4. [ОЖИДАЕМЫЕ РЕЗУЛЬТАТЫ](#res)
5. [ВЫПОЛНЕНИЕ](#action)
    5.1. [Формирование каркаса на Flask](#flask)
    5.2. [Создание БД](#cr_db)
    5.3. [Обработчики ссылок и действий](#links)
    5.4. [Работа с БД](#w_db)
    5.5. [Функции для работы с БД](#func_db)
    5.6. [Вспомогательные функции](#subsidiary)
    5.7. [HTML](#html)
    5.8. [JavaScript](#js)
    5.9. [Формы](#forms)
    5.10. [CSS](#css)
    5.11. [Заключительный этап](#last_step)
    5.12. [Запуск приложения](#launch)
6.  [ДЕМОНСТРАЦИЯ РЕЗУЛЬТАТОВ](#demo)
7.  [ЗАКЛЮЧЕНИЕ](#conclusion)
8.  [СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ](#source)



<br/><br/>
<br/><br/>

<div style="text-align: center"> <h2><a name="teo">ТЕОРЕТИЧЕСКАЯ БАЗА</a></h2></div>

Для создания веб-приложения были выбраны следующие технологии:

* `Python` – высокоуровневый язык программирования, в котором написан «каркас» приложения.
* `SQLite` – это встроенная база данных, которая предоставляет простой и удобный способ хранения данных в приложениях. В `Python` существует модуль `sqlite3`, который позволяет взаимодействовать с базой данных `SQLite`. С помощью этого модуля можно создавать, изменять и удалять таблицы, выполнять SQL запросы, добавлять данные и многое другое.
* `Flask` — это _микрофреймворк_ для языка программирования `Python`, который позволяет легко создавать веб-приложения. Он обладает простым синтаксисом и хорошей документацией, что делает его отличным выбором для быстрого развертывания веб-приложений.
* `HTML` — это основной язык разметки веб-страниц, который используется для создания структуры и содержимого веб-приложения. Он позволяет определить заголовки, параграфы, ссылки, изображения и другие элементы страницы.
* `CSS` — это язык таблиц стилей, который используется для задания внешнего вида элементов веб-страницы. С его помощью можно определить цвета, шрифты, отступы, рамки и другие стилизующие свойства.
* `JavaScript` — это язык программирования, который позволяет добавить интерактивность и динамическое поведение на веб-странице. Но в данном проекте этот язык использовался не столько для анимации, сколько для изменения таблицы с покупками.

> Если в общих чертах, то сначала написан __«каркас» на Python__, потом для созданных  страниц __сделан общий шаблон__, к нему __добавлены  CSS стили__, затем сделаны сами страницы со стилями. Потом реализована __регистрация__ и прописан обработчик со стилями. Далее __авторизация__. В главной странице начали с таблицы, скопированной  с datatables. Потом добавлена __форма для удаления__ записей с помощью JavaScript и __форма для их добавления__.

<br/><br/>

<div style="text-align: center"> <h2><a name="scores">ЦЕЛИ И ЗАДАЧИ</a></h2></div>

Основные цели проекта таковы:

* Написание приложение `FinHelper`, позволяющее пользователю заниматься домашней бухгалтерией, с возможностью добавления, удаления и сортировки данных.
* Также реализация функции сохранения логина в `cookie` файлы __на 1 день__, что значительно ускоряет авторизацию при ежедневном использовании.
* Сохранение данных пользователя в базу данных `SQLite`. В Python есть модуль `sqlite3`, что упрощает работу с БД.
* Изучение микрофреймворка `Flask`, позволяющего легко создавать веб-приложения. Кроме того, он очень востребован в наше время, __и погружение в использование фреймворка поможет с поиском работы???.__

<br/><br/>

<div style="text-align: center"> <h2><a name="tech">ТЕХНИЧЕСКИЕ ТРЕБОВАНИЯ</a></h2></div>

* Компьютер/ноутбук с выходом в Интернет.
* Текстовый редакторы(например, `Visual Studio Code`, `Sublime Text`, etc.).
* Язык программирования `Python`, установленный на компьютер/ноутбук.
* Пакетный менеджер `PIP`, для установки модулей и библиотек(таких как `Flask`, `sqlite3`, etc.).

<br/><br/>

<div style="text-align: center"> <h2><a name="res">ОЖИДАЕМЫЕ РЕЗУЛЬТАТЫ</a></h2></div>

* Приложение для домашней бухгалтерии, с возможностью добавлять, изменять и удалять покупки.
* Сохранение логина в cookie файлы на день.
* Корректная работа приложения.
* Бесперебойная работа БД.

<br/><br/>

<div style="text-align: center"> <h2><a name="action">ВЫПОЛНЕНИЕ</a></h2></div>

Перед выполнением лабораторной работы надо разобраться с основными моментами.

1. Зачем использовать Flask?

`Flask` — это легковесный веб-фреймворк для языка Python, который предоставляет минимальный набор инструментов для создания веб-приложений. На нём можно сделать и лэндинг, и многостраничный сайт с кучей плагинов и сервисов.
У `Flask` много преимуществ, которые выделяют его среди других фреймворков:

* Простой синтаксис — это всё-таки `Python`.
* Удобные шаблоны.
* Много инструментов для гибкой настройки сайтов под любые нужды.

2.	Почему нельзя сохранять данные в Excel?

SQLite обладает рядом преимуществ перед Excel:

* Возможность быстрой обработки огромного объёма данных.
* SQLite доступен под __любой__ язык программирования.
* SQLite обеспечивает более __надежное и безопасное__ хранение данных.
* SQLite поддерживает __многопользовательский__ доступ к данным, в то время как Excel ограничен в возможностях совместной работы над данными.
* В отличие от Excel он __бесплатный__.

3.	Зачем использовать JavaScript?

Может возникнуть вопрос: `«Зачем использовать JS? Приложение же статичное»`.  Да, так и есть, но в данном проекте JS используется для работы с чекбоксами и составлением таблицы.

<br></br>

<div style="text-align: center"> <h3><a name="flask">Формирование каркаса на Flask</a></h3></div>

Мы уже выяснили, что такое `Flask` и зачем он нужен в проекте. Теперь можно перейти к написанию файла `app.py`. При этом надо установить сам фреймворк, для этого в консоль надо прописать:

```s
pip install flask
```
	
Для начала надо импортировать __9__ модулей, при этом __4__ из них нам еще предстоит написать.

```python
from flask import Flask, render_template, url_for, redirect, request, flash, g, jsonify, request, render_template
import sqlite3
import os
from werkzeug.security import generate_password_hash, check_password_hash
from FDataBase import FDataBase
from flask_login import LoginManager, login_user, login_required, logout_user, current_user
from UserLogin import UserLogin
from forms import LoginForm, RegisterForm, NoteIn
from NotesDatabase import NotesDatabase
```

1. Сначала выполним конфигурацию БД:

```python
DATABASE = '/tmp/flsite.db' 
DEBUG = False
SECRET_KEY = 'fdgfh78@#5?>gfhf89dx,v06k'
USERNAME = 'admin'
PASSWORD = '123'
```

> Параметр  __SECRET_KEY__ необходим для безопасной работы сессий на стороне клиента. С помощью этого секретного ключа __выполняется шифрование данных__, которые, затем, сохраняются в __cookie__ браузера. Поэтому, даже глядя на информацию, сохраненную в браузере, пользователь не сможет понять, что она означает. Разумеется, все шифрование Flask выполняет автоматически. От нас требуется только прописать этот ключ с как можно более непонятным набором символов.

2. Создаем само приложение и загружаем конфигурацию из текущего модуля:

```python
app = Flask(__name__)
app.config.from_object(__name__)
```

3. Переопределяем в конфигурации значение `DATABASE`, расположив БД в текущем каталоге приложения:

```python
app.config.update(dict(DATABASE=os.path.join(app.root_path,'flsite.db')))
```
<br></br>
<div style="text-align: center"> <h3><a name="cr_db">Создание БД</a></h3></div>

1. Для начала создадим функцию для установления соединения с БД:

```python
def connect_db():
    conn = sqlite3.connect(app.config['DATABASE'])  
    conn.row_factory = sqlite3.Row
    return conn
```

2. Затем объявим вспомогательную функцию, которая будет создавать начальную БД с набором необходимых таблиц:

```python
def create_db():
    db = connect_db()
    with app.open_resource('sq_db.sql', mode='r') as f:
        db.cursor().executescript(f.read())
    db.commit()
    db.close()
```

3. Реализуем функцию запроса данных в БД:

```python
def get_db():
    if not hasattr(g, 'link_db'):
        g.link_db = connect_db()
    return g.link_db
```

4. И декорированную функцию закрытия БД:

```python
@app.teardown_appcontext
def close_db(error):
    if hasattr(g, 'link_db'):
        g.link_db.close()
```

> __@app.teardown_appcontext__ — это декоратор во Flask, который используется для регистрации функций, которые должны быть выполнены при завершении контекста приложения. Это позволяет освобождать ресурсы или выполнять другие действия после завершения работы приложения. Функции, помеченные этим декоратором, будут вызываться автоматически при завершении контекста приложения.

<br></br>

<div style="text-align: center"> <h3><a name="links">Обработчики ссылок и действий</a></h3></div>

В этом блоке мы напишем функции, выполняющие различные действия:

* Авторизация
* Регистрация
* Добавление записей
* Удаление записей

1. Первое с чего стоит начать – __функция авторизации__. Эта функция обрабатывает действия пользователя, включая нажатие таких кнопок как `«выйти»` и `«запомнить меня»`.

Также понадобится декоратор `@app.route`, принимающий 2 аргумента(URL и методы – в нашем случае: `“/login”` и `[“POST”, “GET”]` соответственно).  И как вы могли заметить, методы `POST` и `GET` — это __HTTP запросы__.

```python
@app.route("/login", methods=["POST", "GET"]) # декоратор для указания на обработчик действия по ссылке /login с get и post методами обмена данных
def login():
    if current_user.is_authenticated: # проверка авторизации пользователя
        return redirect(url_for('main')) # авторизованные пользователи перенаправляются на главную страницу

    db = get_db() # подключение к бд
    dbase = FDataBase(db)   

    form = LoginForm() # подключение формы авторизации из forms

    if form.validate_on_submit(): # нажатие на кнопку "войти"
        user = dbase.getUserByUsername(form.username.data) # получение данных user из бд

        if user and check_password_hash(user['passwd'], form.passwd.data): # если user получен и хеш его пароля совпадает с хэшем введенных символов
            userlogin = UserLogin().create(user) # записываем юзера в залогиненные
            rm = form.remainme.data # "запомнить меня"
            login_user(userlogin, remember = rm) # авторизуем юзера с запоминанием
            resp = redirect(url_for('main')) # записываем перенаправление в resp
            resp.set_cookie('username', form.username.data, max_age = 24 * 60 * 60) # сохраняем юзернейм в куки на 1 день для главной страницы
            return resp # перенаправляем на главную
    
        flash("Неверные данные", category="error") # вывод флеша о неверных данных с css—стилем "error"

    return render_template("login.html", form=form) # отображение соответствующей страницы с формой авторизации    
```

Отметим основные моменты этой функции:

* При отправке формы (метод `POST`) код проверяет данные, введенные пользователем, с помощью метода `form.validate_on_submit()`
*  Если данные проходят валидацию, происходит попытка найти пользователя в базе данных по его имени 
* Затем проверяется соответствие хэшированного пароля пользователя в базе данных с введенным паролем
* Если все данные верны, пользователь авторизуется с помощью `login_user`, и ему устанавливается `cookie` с его именем пользователя __на 24 часа__
* Если данные не прошли валидацию или если произошла ошибка авторизации, пользователю будет показано сообщение об ошибке

> Если пользователь уже авторизован, его перенаправят на главную страницу

2. Также не обойтись без __формы регистрации__, она нужна в том случае, если пользователь еще не пользовался приложением

```python
@app.route('/register', methods = ['POST', 'GET'])
def register():
    db = get_db()
    dbase = FDataBase(db)

    form = RegisterForm() # подключение формы регистрации из forms
    if form.validate_on_submit():
            hash = generate_password_hash(form.passwd.data) # хэширование введенного пароля
            res = dbase.addUser(form.username.data, form.uname.data, # добавление юзера в бд
                                form.surname.data, hash)
            if res: # если успешно добавлен
                flash("Вы успешно зарегистрированы", "success")                         
                user = dbase.getUserByUsername(request.form['username']) # получаем данные юзера и авторизуем его
                userlogin = UserLogin().create(user)
                login_user(userlogin)
                resp = redirect(url_for('main'))
                resp.set_cookie('username', form.username.data, max_age = 24 * 60 * 60)
                return resp
            else:
                flash("Пользователь с таким логином уже есть", category="error")    

    return render_template("register.html", form=form)
```

 !!! важно Важно
    Oдинаковые логины невозможны т.к. поиск в бд записей по логину

Разберем алгоритм работы данной функции:

* При отправке формы (метод `POST`) код проверяет данные, введенные пользователем, с помощью метода `form.validate_on_submit()`
* Если данные проходят валидацию, пароль хэшируется с использованием `generate_password_hash`
* Затем пользователь добавляется в базу данных с помощью метода `dbase.addUser()`
* Если добавление пользователя прошло успешно, пользователю отображается сообщение об успешной регистрации, и он автоматически авторизуется
* Если пользователь с таким логином уже существует, ему будет показано сообщение об ошибке

3. Кроме авторизации и регистрации надо и __добавлять данные__ в БД. Для этого напишем функцию `add_in`, которая отправляет информацию в таблицу(обрабатывает только `POST` запрос)

```python
@app.route('/add_in', methods=['POST'])
def add_in():
    db = get_db()
    dbase = NotesDatabase(db)

    form = NoteIn()
    if form.validate_on_submit():                                                   
            res = dbase.addNote(form.product.data, form.category.data, # внесение записи в бд с указанием юзернейма
                                form.buydate.data, form.cost.data, 
                                request.cookies.get('username'))
            if res:                                                                 
                flash("Запись добавлена", category="success")
                return redirect(url_for('main'))
            else:
                flash("Что—то пошло не так", category="error")
    else:
        flash("Введите цену числом", category="error")
        
    return redirect(url_for('main'))
```

Функция работает по такому принципу:

* Если данные проходят валидацию, то происходит попытка добавить запись в базу данных
    *  Для этого используется экземпляр класса `NotesDatabase`, который получает доступ к базе данных через `get_db()`
* Затем вызывается метод `addNote` этого экземпляра, который добавляет новую запись в базу данных с указанием имени пользователя, полученного из `cookies`
* В конце выводится соответствующее сообщение о добавлении данных

4. Также реализуем функцию `delete_notes` удаления записей из списка покупок. Она также, как и функция `add_in` обрабатывает только POST запрос, а значения получает в виде `JSON файла`.

```python
@app.route('/delete_notes', methods=['POST'])
def delete_notes():
    db = get_db()
    dbase = NotesDatabase(db)
    ids = request.json['ids'] # получение списка удаляемых записей
    if ids:
        if ',' in ids: # список
            ids = ids.split(',')
            resp = dbase.del_notes(ids) # удаление элементов по списку
        else:
            resp = dbase.del_notes([ids]) # удаление одной переменной
		
        if resp:
            resp = jsonify("<div class='good_add'>Записи успешно удалены</div>") # сообщение об успехе выполнения
            resp.status_code = 200
            return resp
        else:
            resp = jsonify("<div class='bad_add'>Что—то пошло не так</div>")
            resp.status_code = 500
            return resp
    else:
        resp = jsonify("<div class='bad_add'>Неверный формат ввода</div>")
        resp.status_code = 400
        return resp
```

Алгоритм работы функции `delete_notes` таков:

* Получение данных в формате `JSON`, содержащих список идентификаторов записей, которые должны быть удалены
* Использование экземпляра класса `NotesDatabase` для удаления записей из базы данных
    * Если удаление прошло успешно, функция возвращает сообщение об успехе и `код состояния 200`
    * В противном случае он возвращает сообщение об ошибке и соответствующий код состояния (`400 или 500`)

5. Помимо всех функций обработчиков надо написать функцию представления главной страницы приложения, на которой отображаются все записи пользователя и предоставляется возможность добавления новых записей.

```python
@login_required # декоратор для доступа только авторизованных пользователей
def main(): # подключение бд записей
    dbase = NotesDatabase(db)

    form = NoteIn() # подключение формы добавления записи

    u_name = request.cookies.get('username') # юзернейм вошедшего извлекаем из куков
    
    if not(u_name): # если куки истекли или их нет сбрасываем на выход
        return redirect(url_for('logout'))

    cur = db.cursor()
    # выбор подходящих записей                                                        
    cur.execute(f"SELECT id, product, category, buydate, cost FROM notes WHERE username LIKE '{u_name}'")
    notes = cur.fetchall() # вывод всех подходящих записей


    return render_template('main.html', notes = notes, form = form) # вывод страницы с записями и формой
```

Алгоритм работы функции:

* Код начинается с проверки, авторизован ли пользователь, используя декоратор `@login_required`
* Затем он получает экземпляр базы данных и экземпляр класса `NotesDatabase`
* Далее он извлекает имя пользователя из `cookie`, и если оно не существует, перенаправляет пользователя на страницу выхода
* Затем он выполняет `SQL—запрос`, чтобы получить все записи, принадлежащие текущему пользователю, и передает их в шаблон `main.html` вместе с формой для добавления записи

6. На последок надо реализовать функцию выхода из системы, которая представляет собой обработчик маршрута `"/logout"`

```python
@app.route('/logout')
def logout():
    resp = redirect(url_for('main'))
    resp.delete_cookie('username') # удаление куков
    logout_user() # выход юзера
    flash('Вы вышли из аккаунта', category="success")
    return redirect(url_for('login')) # пересылка на утентификацию
```

Разберем приницип работы функции:

* Создается объект ответа `resp`, который перенаправляет пользователя на страницу с маршрутом `"main"`
* У объекта resp вызывается метод `delete_cookie('username')`, который удаляет куки с именем `'username'`, если таковые имеются
* Вызывается функция `logout_user()`, которая выполняет выход текущего пользователя из системы (если система аутентификации использует понятие текущего пользователя)
* С помощью функции `flash()` добавляется сообщение `"Вы вышли из аккаунта"` в категорию `"success"`. Это сообщение может быть использовано для отображения пользователю информации о успешном выходе из аккаунта
* Пользователь перенаправляется на страницу с маршрутом `"login"`

!!! note Важно
    В конце кода проверяется, что приложение запускается непосредственно (_а не импортируется как модуль_), и если это так, то оно запускается в режиме отладки `(debug=True)`


6. В конце файла `app.py` надо прописать конструкцию:

```python
if __name__ == "__main__":                                                          
    app.run(debug=True)
```

> При запуске приложения изменить значение __debug__ на __False!__

<br></br>

<div style="text-align: center"> <h3><a name="w_db">Работа с БД</a></h3></div>

Для того, чтобы данные о пользователе и его покупках не уходили вникуда, их надо куда-то сохранять. Для этого используются `базы данных`. Они нужны для хранения и упорядочения данных, чтобы упростить управление ими и доступ к ним. Мы будем использовать `SQLite`. __Но почему?__

> __SQLite__ — это компактная и легкая встраиваемая база данных, которая позволяет хранить и управлять данными прямо внутри вашего приложения. Её простота в использовании и широкая поддержка делают её прекрасным выбором для различных проектов, включая веб-приложения, мобильные приложения и многое другое.

Стоит также отметить, что модуль `sqlite3` входит в стандартуную библиотеку `Python(2.5+)`, поэтому нам не нужно устанавливать её отдельно. Мы можем начать использовать `sqlite3` сразу после установки `Python`.

Но перед началом работы надо сделать сам объект БД. Для этого создадим файл с разрешением `.sql`(например, `sq_db.sql`). И впишем в него следующие строки:

```sql
CREATE TABLE IF NOT EXISTS users (
id integer PRIMARY KEY AUTOINCREMENT,
uname text NOT NULL,
surname text NOT NULL,
username text NOT NULL,
passwd text NOT NULL,
time integer NOT NULL
);
```

Этот код создает таблицу `'users'` в базе данных, __если она(таблица) не существует__. Таблица содержит следующие столбцы:

* `id`: целочисленный `PRIMARY KEY`, который автоматически увеличивается при добавлении новой записи
* `uname`, `surname`, `username` и `passwd`: текстовые поля, предназначенные для __имени пользователя, фамилии, логина и пароля__ соответветственно
* `time`: целочисленное поле, предназначенное для хранения __времени__ (указывается пользователем)

Далее создадим еще одну таблицу `'notes'` для записи информарции уже не о пользователе, а о его покупках.

```sql
CREATE TABLE IF NOT EXISTS notes (
id integer PRIMARY KEY AUTOINCREMENT,
product text NOT NULL,
category text NOT NULL,
buydate date NOT NULL,
cost integer NOT NULL,
username text NOT NULL
);
```
Теперь разберем каждый столбец:
* `id`: целочисленный `PRIMARY KEY`, который автоматически увеличивается при добавлении новой записи
* `category`: текстовое поле, предназначенное для __категории__ продукта
* `buydate`: поле типа `date`, предназначенное для хранения __даты__ покупки
* `cost`: целочисленное поле, предназначенное для хранения __стоимости__ продукта
* `username`: текстовое поле, предназначенное для __логина__, связанного с данной заметкой

<br></br>

<div style="text-align: center"> <h3><a name="func_db">Функции для работы с БД</a></h3></div>

После того, как мы создали таблицы в БД, можно приступать к функциям работы с ними. Будут разобраны такие функции как добавления нового пользователя, добавление записей о покупке и их удаление.

Итак, нам понадобится создать два `Python` файла:

1. `FDataBase.py` — в нем пропишем функцию для работы с пользователем
2. `NotesDatabase.py` — в этом файле пропишем функции обработки записей(добавление/удаление)

Начнем с `FDataBase.py`. 
* Сначала создадим класс `FDataBase`, в котором проведем инициализацию и определим метод добавления пользователя в БД
* В конструкторе класса FDataBase инициализируются атрибуты `__db` и `__cur` с использованием переданной базы данных `db` и инициализируется курсор `db.cursor()`.

```python
class FDataBase:
    def __init__(self, db):
        self.__db = db
        self.__cur = db.cursor()
```
Также необходимо импортировать нужные модули:

```python
import sqlite3
import math
import time
```

Далее определим метод `addUser` для добавления пользователя в БД.

```python
def addUser(self, username, name, surname, hpsw):
    try:
        # проверка, что юзер с таким логином отсутствует
        self.__cur.execute(f"SELECT COUNT() as `count` FROM users WHERE username LIKE '{username}'")
        res = self.__cur.fetchone()
        if res['count'] > 0:
        	print("Пользователь с таким логином уже существует")
        	return False

        tm = math.floor(time.time()) # время авторизации
        self.__cur.execute("INSERT INTO users VALUES(NULL, ?, ?, ?, ?, ?)", (name, surname, username, hpsw, tm))
        self.__db.commit() # добавление юзера в бд

        except sqlite3.Error as e:
            # в случае ошибки
            print("Ошибка добавления пользователя в БД "+str(e))
            return False
    
        return True
```

!!! note Кратко о работе метода
    Формируется запрос в БД, а затем проверяется нет ли уже пользователя с таким же логином.

    * И если пользователь с таким логином уже зарегистрирован, то выводится соответсвующее сообщение
    * В ином случае выводится сообщение об успешной регистрации

    Также возможен вариант с неправильной работой БД, и он в коде тоже обработан.


Теперь перейдем к обработке записей о покупке.

* Создадим файл `NotesDatabase.py`, в котором создадим класс с таким же названием
* Затем импортируем SQLite: `import sqlite3`
* Инициализация проходит в точности также, как и в предыдущем файле


Теперь пропишем метод `addNote`, принимающий помимо экземпляра класса(`self`), еще 5 параметров — `product, category, buydate, cost, username` — информацию о покупке и о самом пользователе(логин). Давайте реализуем этот метод:

```python
def addNote(self, product, category, buydate, cost, username):
    try:
        self.__cur.execute("INSERT INTO notes VALUES(NULL, ?, ?, ?, ?, ?)", (product, category, buydate, cost, username))
        self.__db.commit()

    except sqlite3.Error as e:
        print("Ошибка добавления записи в БД "+str(e))
        return False
    
    return True
```

!!! note Кратко о работе метода
    * Формируется запрос в БД(`'INSERT INTO'`)
    * Затем происходит `commit`, в результате чего данные добавляются в таблицу
    * Если произошла ошибка в соединении с БД, то выводится сообщение: `Ошибка добавления записи в БД <error_name>`

Помимо добавления, записи надо еще и удалять. Для этого определим еще один метод `del_notes`

```python
def del_notes(self, ids):
    try:
        # попытка удалить данные из БД
        self.__cur.execute("DELETE FROM notes WHERE id IN (" + ", ".join(ids) + ")")
        self.__db.commit()

    except sqlite3.Error as e:
        # в случае ошибки
        print("Ошибка удаления записи из БД "+str(e))
        return False
        
    return True
```

!!! note Кратко о работе метода
    * Формируется запрос в БД(`'DELETE FROM'`)
    * Затем происходит `commit`, в результате чего данные удаляются из таблицы
    * Если произошла ошибка в соединении с БД, то выводится сообщение: `Ошибка добавления записи в БД <error_name>`


> По сути __FDataBase.py__ и __NotesDatabes.py__ — два схожих файла, только один работает с пользователем, а второй — с его покупками.

<br></br>

<div style="text-align: center"> <h3><a name="subsidiary">Вспомогательные функции</a></h3></div>

В некоторых функциях файла `app.py` использованы методы класса `UserLogin`, но что это за класс, мы еще не рассказали — исправляемся.


Класс реализует вспомогательные методы, такие как

* `fromDB` — получение данных пользователя
* `create` — запись пользователя как авторизованного
* `get_id` — получение `id` пользователя

Начнем с того, что класс `UserLogin` будет наследоваться от класса `UserMixin`, который надо импортировать из модуля `flask_login`.

> Если вы еще не установили __flask_login__, сделать это можно, прописав в консоль __pip install flask-login__

Стоит также отметить, что класс `UserLogin` надо наследовать от класса `UserMixin`, для этого проимпортируем этот класс:
```python
from flask_login import UserMixin
```

Теперь перейдем к написанию методов. Сначала напишем метод `fromDB`.

```python
def fromDB(self, user_id, db):
    # получение данных о пользователе
    self.__user = db.getUser(user_id)
    return self
```

!!! note Кратко о работе метода
    * Метод принимает `user_id` (идентификатор пользователя) и объект `db` (объект базы данных)
    * Затем создается аттрибут `self.__user`, в котором хранятся полученные данные о пользователе из БД
    * Возвращается экземпляр класса `UserLogin`

Для установки пользователя как авторизированного реализуем метод `create`.

```python
def create(self, user):
    self.__user = user
    return self
```

Метод довольно прост: мы создаем аттрибут объекта и затем возвращаем объект.

И последний метод, который реализуем в этом файле — `get_id`. Он нужен для получения `id` пользователя.

```python
def get_id(self):
    return str(self.__user['id'])
```

Этот метод также довольно прост: мы возвращаем `id` пользователя в строковом виде. На этом написание всмпомогательных функций закончено.

<div style="text-align: center"> <h3><a name="html">HTML</a></h3></div>

Мы написали все функции обработки действий, запросов в БД, но так и не создали `"фундамент"` приложения. В этом нам поможет язык гипертекстовой разметки `HTML`.

Для написания скрипта на `HTML` используются тэги, и работать с ним очень просто. Нам понадобится написать 4 страницы:

* `base.html`
* `register.html`
* `login.html`
* `main.html`

1. `HTML` скрипт состоит из двух частей: `head` — служебная информация и `body` — контент, отображающийся на веб-странице. И начнем мы писать наш `"фундамент"` с `base.html`.

Сначала пропишем:

```html
<!DOCTYPE html>
<html lang="ru">
```

`DOCTYPE`, как понятно из названия нужен для указания типа документа, а `lang` — языка.


Далее пропишем `<head>`:
```html
<head>
    <title>{% block title %}{% endblock %}</title>
    <link rel="icon" href="{{ url_for('static', filename='coin_money_icon—icons.com_51091.ico') }}" type="image/x—icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/main.css') }}">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='styles/dataTables.bootstrap5.css') }}">
</head>
```

!!! note Кратко о тэге head
    * Создаем название веб-страницы
    * Прописываем ссылку на иконку
    * Обозначаем ссылки на стили (`CSS`)

Затем прописываем тэг `<body>`:

```html
<body>
    <div class="hat">
        <div class="name_box">
            <img src="{{ url_for('static', filename='piggy—bank_115176.png') }}" width="21px">
            <div class="main_name">Finance Helper</div>
        </div>
        <div class="status_change">
            {% block status %}{% endblock %}
        </div>
    </div>
    <div class="free_space"></div>
    {% block body %}{% endblock %}
    <script type="text/javascript" charset="utf8" src="https://code.jquery.com/jquery—3.6.0.min.js"></script>
    <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.10.25/js/jquery.dataTables.js"></script>
    <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.10.25/js/dataTables.bootstrap5.js"></script>
    <script type="text/javascript" src="https://cdn.datatables.net/fixedheader/3.2.3/js/dataTables.fixedHeader.min.js"></script>
</body>
</html>
```

!!! note Кратко о тэге body
    * Создаем несколько блоков (тэг `div`), предназначенных для заголовка, содержимого и свободного пространства, которые заполнены в _дочерних шаблонах_
    * Подключаем `JS` скрипты, с помощью тэга `script`

2. Далее пропишем страницу авторизации. Назовем файл `login.html`. Здесь уже не будет тэгов `head` и `body`, поскольку это дочерние классы.

```html
{% extends 'base.html' %}

{% block status %}
<div>
    <a class="main_ref" href="/register">Регистрация</a>
</div>
{% endblock %}

{% block title %}
Авторизация
{% endblock %}

{% block action %}

{% endblock %}

{% block body%}
```

Это первая часть нашего второго файла и сейчас мы расскажем, что здесь написано.

!!! note Кратко о login.html (1)
    * `{% block status %}` определяет содержимое для раздела статуса (содержит ссылку на страницу регистрации)
    * `{% block title %}` определяет заголовок страницы (`"Авторизация"`)
    * `{% block action %}` определяет действие страницы
    * `{% block body %}` определяет основное содержимое страницы. В данном случае, он оставлен пустым, что означает, что _основное содержимое будет вставлено из дочернего шаблона_

Далее пропишем форму для авторизации, которая будет в себя включать поля для ввода имени пользователя, пароля и чекбокс `"Запомнить меня"`, а также кнопку для отправки формы.

```html
<div class="outter_block">
    <div class="main_block">
        <div class="log_block">
            <div class="autorization">
                <h1>Авторизация</h1>
                <form class="login_form" action="/login" method="post">
                    {% for cat, msg in get_flashed_messages(True) %}
                    <div class="flash {{cat}}">{{msg}}</div>
                    {% endfor %}
                    {{ form.hidden_tag() }}
                    <p> {{ form.username.label() }} 
                        {% if form.username.errors %}
                            {{ form.username() }}
                        <span>
                            {% for e in form.username.errors %}
                                {{ e }}
                            {% endfor %}
                        </span>
                        {% else %}
                            {{ form.username() }}
                        {% endif %}
                    </p>
                    <p> {{ form.passwd.label() }} 
                        {% if form.passwd.errors %}
                            {{ form.passwd() }}
                        <span>
                            {% for e in form.passwd.errors %}
                                {{ e }}
                            {% endfor %}
                        </span>
                        {% else %}
                            {{ form.passwd() }}
                        {% endif %}
                    </p>
                    <p> {{ form.show_password }} </p>
                    <p> {{ form.remainme.label() }}  {{ form.remainme() }}</p>
                    <p> {{ form.submit() }}</p>
                </form>
            </div>
        </div>
    </div>
</div>
{% endblock %}
```

!!! note Кратко о login.html (2)
    * Создаются блоки, в последнем из которых прописываем тэг `form` — __форма регистрации__ (форма отправляется на сервер по адресу `'/login'` методом `POST`)
    * В форме прописан __обработчик ошибок__ (неправильное имя пользователя или пароль) и __отображение сообщений об ошибках пользователю__

3. После того, как написали основной файл (`base.html`) и файл авторизации (`login.html`), надо обозначить и страницу авторизации. Назовем файл `register.html`.

Также разобьем файл на два участка. Разберем первый:

```html
{% extends 'base.html' %}

{% block status %}
<div>
    <a class="main_ref" href="/login">Вход</a>
</div>
{% endblock %}

{% block title %}
Регистрация
{% endblock %}

{% block body%}
```

Здесь код очень похож на первую часть предыдущего файла, за исключением того, что заголовок `'Регистрация'`, а `'block status'` содержит ссылку на форму авторизации.

Теперь разберем вторую часть `register.html`.

```html
<div class="outter_block">
    <div class="main_block">
        {% for cat, msg in get_flashed_messages(True) %}
        <div>{{msg}}</div>
        {% endfor %}
        <div class="reg_block">
            <div class="registration">
                <h1>Регистрация</h1>
                <form class="reg_form" action="/register" method="post">
                    {% for cat, msg in get_flashed_messages(True) %}
                    <div class="flash {{cat}}">{{msg}}</div>
                    {% endfor %}
                    {{ form.hidden_tag() }}
                    {% for field in form if field.name not in ['csrf_token', 'submit'] %}
                        <p> {{ field.label() }} 
                            {% if field.errors %}
                                {{ field() }}
                            <p class="invalid">
                                {% for e in field.errors %}
                                    {{ e }}
                                {% endfor %}
                            </p>
                            {% else %}
                                {{ field() }}
                            {% endif %}
                        </p>
                    {% endfor %}
                    <p> {{ form.submit(class="reg_sub") }}</p>
                </form>
            </div>
        </div>
    </div>
</div>
{% endblock %}
```

!!! note Кратко о register.html (2)
    * В основном блоке выводятся сообщения с помощью цикла `for`, который проходит по всем сообщениям, полученным с помощью функции `get_flashed_messages()` и выводит их в блоке `<div>`
    * Затем идет блок для регистрации, который содержит форму регистрации с полями для ввода данных
    * Цикл for также используется для вывода сообщений об ошибках ввода данных
    * В конце формы выводится кнопка отправки данных

4. Последний `HTML` скрипт — это `main.html`. В нем отображается информация уже после регистрации и авторизации, а именно сама таблица с покупками.

Сначала рассмотрим первую часть. Этот класс также является дочерним для `base.html`, но ссылку содержит на `logout`.

```html
{% extends 'base.html' %}

{% block status %}
<div>
    <a class="main_ref" href="/logout">Выход</a>
</div>
{% endblock %}
```

Во второй части все гораздо сложнее...

```html
{% block body%}
<script type="text/javascript" src="https://code.jquery.com/jquery—3.5.0.min.js"></script>
<script type="text/javascript" src="{{ url_for('static', filename='app.js') }}"></script>
<div class="main_block">
	<div class="notes_block">
		<div class="inner_notes">
			<div id="body">
				<div class="notes_hat">
					<h1>Ваш список покупок</h1>
					{% for cat, msg in get_flashed_messages(True) %}
						<div class="flash {{cat}}">{{msg}}</div>
					{% endfor %}
				</div>
				<form action="/add_in" method="post">
					<div class="add_block">
						{{ form.hidden_tag() }}
						{% for field in form if field.name not in ['csrf_token', 'submit'] %}
							<p>	{% if field.errors %}
									{{ field() }}
								<p class="invalid">
									{% for e in field.errors %}
										{{ e }}
									{% endfor %}
								</p>
								{% else %}
									{{ field() }}
								{% endif %}
							</p>
						{% endfor %}
						<p> {{ form.submit() }}</p>
					</div>
				</form>
				{% if notes %}
					<div class="del_menu">
						<button id="delete_notes">Удалить выбранный(е) продукт(ы)</button>
						<div id="msg"></div>
					</div>
					<table id="data" class="datatable">
						<thead>
							<tr>
								<th><input id="check_all" type="checkbox"></th>
								<th>Название</th>
								<th>Категория</th>
								<th>Дата</th>
								<th>Цена</th>
							</tr>
						</thead>
						<tbody>
							{% for p in notes %}
								{% set row_class = 'odd_col' %}
								<tr class="{{ row_class }}">
									<td><input type="checkbox" name="row-check" value="{{ p['id'] }}"></td>
									<td>{{ p['product'] }}</td>
									<td>{{ p['category'] }}</td>
									<td>{{ p['buydate'] }}</td>
									<td>{{ p['cost'] }}</td>
								</tr>
							{% endfor %}
						</tbody>
					</table>
					{% else %}
						<div><p style="font—size: 15pt;">Записи отсутствуют</p></div>
				{% endif %}
			</div>
		</div>
	</div>
</div>
```

Сейчас попробуем объяснить, что же тут написано.

!!! note Кратко о main.html (2)
    * В начале страницы подключаются скрипты `jQuery` и `app.js`
    * Затем идет блок `'main_block'`, в котором содержатся блоки для отображения списка покупок и формы добавления новых покупок
    * В блоке `'body'` выводятся сообщения о добавлении новых покупок (__если они есть__) с помощью цикла `for`
    * После этого идет __форма добавления новых покупок__, которая содержит поля для ввода данных. Если при вводе данных возникают ошибки, они также выводятся с помощью цикла `for`
    * Если список покупок не пустой (`notes`), то выводится __таблица с покупками__, а также __кнопка для удаления выбранных записей__. Если список покупок пустой, выводится сообщение `"Записи отсутствуют"`

Но это еще не все. Ведь нам еще надо отобразить интерактивную таблицу для списка покупок.

```html
<script>
    $(document).ready(function () {
      $('#data').DataTable( {
		"language": {
    		"search": "Фильтровать покупки:",
			"lengthMenu": "Показать _MENU_ покупок",
			"info": "Показано с _START_ по _END_ из _TOTAL_ покупок",
			"infoEmpty": "Показано с 0 по 0 из 0 покупок",
			"paginate": {
				"first": "Первая",
				"last": "Последняя",
				"next": "Cледующая",
				"previous": "Предыдущая",
				"infoFiltered": "",
			},
			"infoFiltered": "",
			"zeroRecords": "Не найдено подходящих записей",
		},
		"lengthMenu": [[9, 25, 50, —1], [9, 25, 50, "Все"]]
	  } );
    });
</script>
{% endblock %}
```

!!! note Кратко о main.html (3)
    *  В блоке функции `ready` указывается, что скрипт будет выполняться __после загрузки документа__
    * Затем идет инициализация DataTable с определенными параметрами
        * В параметре `'language'` указываются тексты для различных элементов интерфейса таблицы (например, _текст для поиска, информации о количестве записей_ и т.д.)
    * Параметр `'lengthMenu'` определяет варианты выбора количества записей на странице

> Таким образом, этот скрипт настраивает __DataTables__ для отображения списка покупок в виде интерактивной таблицы с возможностью __фильтрации__, __выбора количества записей__ на странице и другими функциями.

<br></br>

<div style="text-align: center"> <h3><a name="js">JavaScript</a></h3></div>

Как было сказано ранее, `JS` в нашем проекте нужен для обработки нажатия кнопок и чекбоксов. В этом разделе мы реализуем соответствующие функции.

1. Начнем с обработчика событий `click` для элемента с `id 'check_all'`. Он нужен для выбора всех элементов, а при повторном нажатии — наоборот все выделения снимаются.

```js
$("#check_all").on("click", function () {
    if ($("input:checkbox").prop("checked")) {
        // установление чекбокса в True
        $("input:checkbox[name='row-check']").prop("checked", true);
    } else {
        // отключение чекбоксов при повторном нажатии
        $("input:checkbox[name='row-check']").prop("checked", false);
	}
});
```

!!! note Кратко о click (для check_all)
    *  Когда этот чекбокс нажимается, скрипт проверяет, отмечен ли он. Если он отмечен, то все чекбоксы с именем `'row-check'` также отмечаются
    * Если он не отмечен, то все чекбоксы с именем `'row-check'` снимают отметку

2. Также установим обработчик события `change` для всех чекбоксов с именем `'row-check'`.

```js
$("input:checkbox[name='row-check']").on("change", function () {
    // вызов только при изменении значения чекбокса
    var total_check_boxes = $("input:checkbox[name='row-check']").length;
    // количество всех чекбоксов
    var total_checked_boxes = $("input:checkbox[name='row-check']:checked").length;
    // количество выбранных
    
    // если выбраны все чеки то автоматически выбирается и верхний в шапке таблицы
    if (total_check_boxes === total_checked_boxes) {
        $("#check_all").prop("checked", true);
    }
    else {
        $("#check_all").prop("checked", false);
    }
});
```

!!! note Кратко о change
    * Когда состояние любого из этих чекбоксов изменяется, скрипт подсчитывает общее количество всех чекбоксов и количество выбранных чекбоксов
    * Затем он проверяет, если все чекбоксы выбраны, то отмечает чекбокс с `id 'check_all'`, иначе снимает отметку

3. И наконец напишем код установки обработчка события `click` для элемента с `id 'delete_notes'`.

```js
$("#delete_notes").on("click", function () {
    var ids = '';
    var comma = '';

    // запись чекбоксов для удаления и формирование списка ids, состоящего из данных по записям
    $("input:checkbox[name='row-check']:checked").each(function() {
        ids = ids + comma + this.value; // добавление текущих данных для уже записанных
        comma = ',';
    });		
		
    // обработка сообщений
    if(ids.length > 0) {
        $.ajax({
            type: "POST",
            contentType: 'application/json;charset=UTF-8',
            url: "/delete_notes",
            data: JSON.stringify({'ids': ids}),
            dataType: "json",
            cache: false,
            // успешное удаление
            success: function(msg) {
                $("#msg").html(msg);
                // вывод сообщения в объект с id #msg
                setTimeout(function() {
                    location.reload();
                    // перезагрузка страницы после задержки в 900 милисекунд 
                }, (900));
									
            },
            // непредвиденная ошибка удаления
            error: function(jqXHR, textStatus, errorThrown) {
                $("#msg").html("<span style='color:red;'>" + textStatus + " " + errorThrown + "</span>");
            }
        });
        
    // не выбраны элементы
    } else {
        $("#msg").html("<div class='bad_add'>Для удаления выберите хотя бы один элемент</div>");
    }
});
```

!!! note Кратко о click (для delete_notes)
    * Когда элемент `delete_notes` нажимается, скрипт собирает значения выбранных чекбоксов с именем `'row-check'` и отправляет их на сервер методом `POST`
    * После успешного удаления записей скрипт отображает сообщение об успешном удалении и перезагружает страницу через `900 миллисекунд`
    * В случае ошибки удаления, скрипт также отображает сообщение об ошибке
    
    Если не выбраны элементы, скрипт выводит сообщение о необходимости выбрать хотя бы один элемент для удаления.

<br></br>

<div style="text-align: center"> <h3><a name="forms">Формы</a></h3></div>

Самое время прописать формы для нашего веб-приложения. Для этого сначала надо установить модуль `flask_wtf`:

```
pip install Flask-WTF
```

Далее импортируем все необходимые модули:

```python
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField, BooleanField, PasswordField, DateField, FloatField
from wtforms.validators import DataRequired, Length, EqualTo
from datetime import date
```

Итак, первую форму, которую мы пропишем — __форму авторизации__.

```python
class LoginForm(FlaskForm):
    username = StringField('Логин: ', validators = [DataRequired(), Length(min = 3)], render_kw={"placeholder": "Введите логин"}) # длина логина от 3 до 33
    passwd = PasswordField('Пароль: ', validators = [DataRequired(), Length(min = 6)], render_kw={"placeholder": "Введите пароль"})
    remainme = BooleanField('Запомнить меня', default = False)
    submit = SubmitField('Войти')
```

Эта содержит поля:

1. `'username'` — _логин_
2. `'passwd'` — _пароль_
3. `remainme` — _запомнить меня_


Вторая форма, которую мы напишем — __форма регистрации__.

```python
### Форма регистрации
class RegisterForm(FlaskForm):
    uname = StringField('Имя: ', validators = [DataRequired()], render_kw={"placeholder": "Введите имя"})
    surname = StringField('Фамилия: ', validators = [DataRequired()], render_kw={"placeholder": "Введите фамилию"})
    username = StringField('Логин: ', validators = [DataRequired(), Length(min = 3)], render_kw={"placeholder": "Введите логин (не менее 3 символов)"})
    passwd = StringField('Пароль: ', validators = [DataRequired(), Length(min = 6)], render_kw={"placeholder": "Введите пароль (не менее 6 символов)"})
    passwd2 = StringField('Повторите пароль: ', validators = [DataRequired(), Length(min = 6), EqualTo('passwd', message='Пароли не совпадают')], render_kw={"placeholder": "Повторите пароль"})
    submit = SubmitField('Зарегистрироваться')
```

Она содержит поля:

1. `'uname'` — _имя_
2. `'surname'` — _фамилия_
3. `'username'` — _логин_
4. `'passwd'` — _пароль_
5. `'passwd2'` — _повтор пароля_.

И последняя форма, которую надо прописать — это __форма добавления записи__ — `NoteIn`.
```python
class NoteIn(FlaskForm):
    product = StringField(validators = [DataRequired(), Length(min = 1, max = 21)], render_kw={"placeholder": "Название"})
    category = StringField(validators = [DataRequired(), Length(min = 1, max = 21)], render_kw={"placeholder": "Категория"})
    buydate = DateField(default=date.today, render_kw={"placeholder": "Дата"})
    cost = FloatField(validators = [DataRequired()], render_kw={"placeholder": "Стоимость (до 10 млн)"})
    submit = SubmitField('  Добавить покупку  ') 
```

Эта форма содержит следующие поля:

1. `'product'` — _название продукта_
2. `'category'` — _категория_
3. `'buydate'` — _дата покупки_
4. `'cost'` — _стоимость_

> Каждое поле имеет свои __валидаторы__, которые определяют правила для заполнения поля (например, _обязательное поле, минимальная/максимальная длина, равенство другому полю_ и т.д.)
Кроме того, для некоторых полей установлены __placeholder__'ы — _подсказки для пользователя_

<br></br>

<div style="text-align: center"> <h3><a name="css">CSS</a></h3></div>

`CSS (Cascading Style Sheets)` — это формальный язык декорирования и описания внешнего вида документа. Он позволяет делать веб-страницу _более привлекательной_.

Стилей для приложения довольно много, поэтому предлагаем Вам не писать их, а воспользоваться уже написанными нами: <a href="https://github.com/IlyaChern12/FinHelper/blob/main/static/styles/main.css">main.css</a>, <a href="https://github.com/IlyaChern12/FinHelper/blob/main/static/styles/dataTables.bootstrap5.css">dataTables.bootstrap.css</a>.

Часть стилей взята с сайтов <a href="https://getbootstrap.ru/?ysclid=lqih7abexv567911255">Bootstrap</a> и <a href="https://www.datatables.net/">Datatables</a>.

<br></br>

<div style="text-align: center"> <h3><a name="last_step">Заключительный этап</a></h3></div>

Итак, мы прописали все необходимые файлы, поработали с `Flask`, `SQLite` и другими инструментами. Но приложению чего-то не хватает. Иконок. Вы можете взять их отсюда:
* <a href="https://github.com/IlyaChern12/FinHelper/blob/main/static/coin_money_icon-icons.com_51091.ico">coin_money_icon-icons.com_51091.ico</a>
* <a href="https://github.com/IlyaChern12/FinHelper/blob/main/static/piggy-bank_115176.png">piggy-bank_115176.png</a>.

И для более упорядоченного вида, создадим дополнительно каталоги:

* `template`: поместим в него все `HTML` файлы
* `static`: в него вложим иконки, файл `app.js` и создадим в нем каталог `styles`
    * `styles`: в него поместим `CSS` файлы

<br></br>

<div style="text-align: center"> <h3><a name="launch">Запуск приложения</a></h3></div>

Итак, то чего мы все так долго ждали. Мы долго писали все необходимые файлы, обрабатывали команды, реализовали различные функции. __Но как запустить приложение?__

Тут все довольно просто.

1. Заходим в `app.py` и меняем значение `debug`(в самом конце кода) на `False`: `app.run(debug=False)`
2. Запускаем файл `app.py`
3. Переходим по адресу, указанному в терминале

<br></br>

<div style="text-align: center"> <h2><a name="demo">ДЕМОНСТРАЦИЯ РЕЗУЛЬТАТОВ</a></h2></div>

![Регистрация](https://github.com/IlyaChern12/FinHelper/blob/main/reg.jpg)

Регистрация

![Авторизация](https://github.com/IlyaChern12/FinHelper/blob/main/enter.jpg)

Авторизация

![Таблица](https://github.com/IlyaChern12/FinHelper/blob/main/main.png)

Таблица


<br></br>

<div style="text-align: center"> <h2><a name="conclusion">ЗАКЛЮЧЕНИЕ</a></h2></div>

В создании веб-приложения с использованием таких технологий как `Flask, SQL, SQLite, HTML, CSS и JavaScript` были использованы современные технологии для разработки полноценного веб-приложения. `Flask` был выбран в качестве фреймворка для облегчения создания веб-приложения, а `SQLite` - в качестве базы данных для хранения информации.

`HTML, CSS и JavaScript` были использованы для создания пользовательского интерфейса веб-приложения. `HTML` обеспечил структуру страницы, `CSS` - стилизацию и внешний вид, а `JavaScript` - интерактивность, динамическое поведение.

`SQL` был использован для работы с базой данных `SQLite`, что позволило хранить и извлекать данные из приложения. Благодаря этим технологиям удалось создать функциональное и удобное веб-приложение, способное обрабатывать данные пользователя и предоставлять интерактивный пользовательский опыт.

<br></br>

<div style="text-align: center"> <h2><a name="source">СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ</a></h2></div>

1. <a href="https://getbootstrap.ru/?ysclid=lqih7abexv567911255">Bootstrap</a>
2. <a href="https://www.datatables.net/">Datatables</a>
3. <a href="https://habr.com/ru/articles/">Хабр</a>
4. <a href="https://www.youtube.com/watch?v=6jxveKOdyNg&list=PLA0M1Bcd0w8yrxtwgqBvT6OM4HkOU3xYn&pp=iAQB">YouTube</a>
5. <a href="https://stackoverflow.com/">StackOverflow</a>
